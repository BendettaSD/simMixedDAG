library(simMixedDAG)
library(dagitty)
require(carData); require(dagitty)
data("GSSvocab")
GSSvocab <- GSSvocab[complete.cases(GSSvocab), ]
g <- dagitty("dag {
ageGroup [pos=\"0,0\"]
vocab [pos=\"1,-1\"]
nativeBorn [pos=\"2,-2\"]
educ [pos=\"3,-1\"]
gender [pos=\"4,0\"]
nativeBorn -> educ
nativeBorn -> vocab
educ -> vocab
gender -> educ
ageGroup -> vocab
}")
plot(g)
non_param_dag_model <- non_parametric_dag_model(dag = g, data = GSSvocab)
nativeBorn_ate_on_vocab <- get_ate(non_param_dag_model, treatment = "nativeBorn", exposure = "vocab")
print()
library(simMixedDAG)
require(carData); require(dagitty)
data("GSSvocab")
GSSvocab <- GSSvocab[complete.cases(GSSvocab), ]
g <- dagitty("dag {
ageGroup [pos=\"0,0\"]
vocab [pos=\"1,-1\"]
nativeBorn [pos=\"2,-2\"]
educ [pos=\"3,-1\"]
gender [pos=\"4,0\"]
nativeBorn -> educ
nativeBorn -> vocab
educ -> vocab
gender -> educ
ageGroup -> vocab
}")
plot(g)
non_param_dag_model <- non_parametric_dag_model(dag = g, data = GSSvocab)
nativeBorn_ate_on_vocab <- get_ate(non_param_dag_model, treatment = "nativeBorn", exposure = "vocab")
print()
treatment = "nativeBorn"
non_param_dag_model$gam_fits[[treatment]]$target_levels
#' @title Get \eqn{ATE} for a non paramteric DAG model
#'
#' @description \code{get_ate.non_parametric_dag_model} uses simulations
#'   to calculate the average treatment effect (\eqn{ATE}) of
#'   a treatment variable on an exposure variable given
#'   a non parametric DAG model.
#'
#' @param dag_model An object of class "non_parametric_dag_model".
#' @param treatment Name of the treatment variable.
#' @param treatment_vals A vector of treatment values to be considered.
#' @param exposure Name of the exposure variable.
#' @param M Number of simulations to run. Each simulation dataset consists of 1000 observations.
#' @return A data.frame with 3 columns:
#'   1. From: The baseline treatment value.
#'   1. To: The value a treatment was changed to.
#'   1. ATE: The average treatment effect of changing the treatment
#'   value from "From" to "To.
#' @example examples/example_get_ate.non_parametric_dag_model.R
#' @seealso \code{\link{get_ate.parametric_dag_model}} for parametric DAG model \eqn{ATE} calculation.
#' @importFrom dagitty parents
#' @export
get_ate.non_parametric_dag_model <- function(dag_model, treatment = NULL, treatment_vals = NULL, exposure = NULL, M = 1000) {
N <- 1000
dag <- dag_model$dag
gam_fits <- dag_model$gam_fits
if (gam_fits[[exposure]]$node_type != "continuous") stop("Exposure must be continuous")
if (is.null(treatment_vals)) {
if(gam_fits[[treatment]]$node_type == "continuous"){
sample_treatment <- sim_mixed_dag(dag_model)[[treatment]]
treatment_vals <- unname(quantile(sample_treatment, seq(0.05, 0.95, by = 0.3)))
} else if (gam_fits[[treatment]]$node_type == "discrete"){
treatment_vals <- factor(non_param_dag_model$gam_fits[[treatment]]$target_levels)
}
}
results <- matrix(ncol = length(treatment_vals), nrow = M)
ans <- data.frame(from = head(treatment_vals, -1), to = tail(treatment_vals, -1), ATE = NA)
vars <- names(dag)
vars <- vars[vars != treatment]
parents <- setNames(lapply(vars, function(var) dagitty::parents(dag, var)), vars) # TODO don't simulate detached nodes after removing treatment
env <- environment()
for (i in 1:length(treatment_vals)) {
treatment_ls <- setNames(list(rep(treatment_vals[i], N)), nm = treatment)
for (m in 1:M) {
sim_data <- do.call(sim_mixed_dag, list(dag_model = dag_model, N = N, treatment_list = treatment_ls))
results[m, i] <- mean(sim_data[[exposure]])
}
}
ans$ATE <- diff(apply(results, 2, mean))
return(ans)
}
nativeBorn_ate_on_vocab <- get_ate(non_param_dag_model, treatment = "nativeBorn", exposure = "vocab")
#' @title Get \eqn{ATE} for a non paramteric DAG model
#'
#' @description \code{get_ate.non_parametric_dag_model} uses simulations
#'   to calculate the average treatment effect (\eqn{ATE}) of
#'   a treatment variable on an exposure variable given
#'   a non parametric DAG model.
#'
#' @param dag_model An object of class "non_parametric_dag_model".
#' @param treatment Name of the treatment variable.
#' @param treatment_vals A vector of treatment values to be considered.
#' @param exposure Name of the exposure variable.
#' @param M Number of simulations to run. Each simulation dataset consists of 1000 observations.
#' @return A data.frame with 3 columns:
#'   1. From: The baseline treatment value.
#'   1. To: The value a treatment was changed to.
#'   1. ATE: The average treatment effect of changing the treatment
#'   value from "From" to "To.
#' @example examples/example_get_ate.non_parametric_dag_model.R
#' @seealso \code{\link{get_ate.parametric_dag_model}} for parametric DAG model \eqn{ATE} calculation.
#' @importFrom dagitty parents
#' @export
get_ate.non_parametric_dag_model <- function(dag_model, treatment = NULL, treatment_vals = NULL, exposure = NULL, M = 1000) {
N <- 1000
dag <- dag_model$dag
gam_fits <- dag_model$gam_fits
if (gam_fits[[exposure]]$node_type != "continuous") stop("Exposure must be continuous")
if (is.null(treatment_vals)) {
if(gam_fits[[treatment]]$node_type == "continuous"){
sample_treatment <- sim_mixed_dag(dag_model)[[treatment]]
treatment_vals <- unname(quantile(sample_treatment, seq(0.05, 0.95, by = 0.3)))
} else if (gam_fits[[treatment]]$node_type == "discrete"){
treatment_vals <- factor(non_param_dag_model$gam_fits[[treatment]]$target_levels)
}
}
results <- matrix(ncol = length(treatment_vals), nrow = M)
ans <- data.frame(from = head(treatment_vals, -1), to = tail(treatment_vals, -1), ATE = NA)
vars <- names(dag)
vars <- vars[vars != treatment]
parents <- setNames(lapply(vars, function(var) dagitty::parents(dag, var)), vars) # TODO don't simulate detached nodes after removing treatment
env <- environment()
for (i in 1:length(treatment_vals)) {
treatment_ls <- setNames(list(rep(treatment_vals[i], N)), nm = treatment)
for (m in 1:M) {
sim_data <- do.call(sim_mixed_dag, list(dag_model = dag_model, N = N, treatment_ls))
results[m, i] <- mean(sim_data[[exposure]])
}
}
ans$ATE <- diff(apply(results, 2, mean))
return(ans)
}
nativeBorn_ate_on_vocab <- get_ate(non_param_dag_model, treatment = "nativeBorn", exposure = "vocab")
remove.packages("simMixedDAG")
#' @title get_ate
#'
#' @description \code{get_ate} is a generic function used to
#'   get average treatment effects (\eqn{ATE}) in a DAG model.
#'
#' @param dag_model An object of either class "paramteric_dag_model" or
#'   "non_paramteric_dag_model".
#' @param ... Additional arguments to dispatched method.
#' @return A data.frame with 3 columns:
#'   1. From: The baseline treatment value.
#'   1. To: The value a treatment was changed to.
#'   1. ATE: The average treatment effect of changing the treatment
#'   value from "From" to "To.
#' @seealso \code{\link{get_ate.non_parametric_dag_model}}, \code{\link{get_ate.parametric_dag_model}}
#' @export
get_ate <- function(dag_model, ...) UseMethod("get_ate")
#' @title Specify a non parametric DAG model
#'
#' @description \code{non_parametric_dag_model} is used to specify non paramteric
#'   DAG models. The non parametric node functions are obtained by fitting generalized
#'   additive models to a supplied (usually "real life") dataset.
#'   The resulting obejct of class "non_parametric_dag_model" has methods to simulate
#'   observations from the model specified and get \eqn{ATE}s.
#'
#' @details Every node \eqn{j} in a non parametric DAG model is simulated from a
#'   non paramteric function of the node parents \code{PA_{j}}:
#'
#'   \deqn{f_j(PA_j) = g(\sum_{i \in PA_j}s_{ij}(x_i) + \epsilon_j)}
#'
#'   The smooth functions \eqn{s_{ij}(.)} are obtained by fitting generalized
#'   additive model to the node (as a reponse) and it's parents (as predictors).
#'
#' @param dag An object of class "dagitty" representing the DAG.
#' @param data A data.frame to be used for fitting the GAMs (no missing values allowed).
#' @return An object of class "non_parametric_dag_model" which is essentially a list containing the following
#'   elements:
#'   1. dag: The model DAG
#'   1. gam_fits: All smoothing functions and other information required for simulating
#'     new datasets from the specified dag model
#' @example examples/example_sim_mixed_dag.parametric_dag_model.R
#' @seealso \code{\link{parametric_dag_model}} for parametric DAG model specification. Methods for
#'   the non_parametric_dag_model class include \code{\link{sim_mixed_dag.non_parametric_dag_model}} for
#'   simulating datasets and \code{\link{get_ate.non_parametric_dag_model}} for getting \eqn{ATE}s.
#' @importFrom dagitty parents
#' @import gam
#' @importFrom mgcv gam gam.fit s gam.control
#' @export
non_parametric_dag_model <- function(dag, data) {
if (mean(names(dag) %in% names(data)) != 1) stop("Some DAG nodes not found in data")
if (any(is.na(data))) stop("data contains missing values")
data <- data[names(dag)]
character_variables <- which(sapply(data, is.character))
data[character_variables] <- lapply(data[character_variables], function(x) factor(x))
two_level_variables <- which(sapply(data, function(x) length(unique(x)) == 2))
data[two_level_variables] <- lapply(data[two_level_variables], function(x) factor(x)) # code 2 value variables as binary
vars <- names(dag)
ans <- setNames(object = vector(mode = "list", length = length(vars)), nm = vars)
for (var in vars) {
var_parents <- parents(dag, var)
ans[[var]]$parents <- var_parents
if (class(data[[var]]) == "factor") {
ans[[var]]$node_type <- "discrete"
ans[[var]]$target_levels <- levels(data[[var]])
num_levels <- length(levels(data[[var]]))
if(length(var_parents) == 0){
forms <- " ~ 1"
} else {
forms <- paste0(" ~ ", paste0(sapply(var_parents, function(var_parent) {
if (class(data[[var_parent]]) == "factor") {
return(var_parent)
} else {
return(paste0("s(", var_parent, ")"))
}
}), collapse = " + "))
}
forms <- lapply(unlist(strsplit(paste0(var, paste0(rep(forms, num_levels - 1), collapse = ", ")), ",")), as.formula)
if(length(forms) == 1) forms <- forms[[1]]
dat <- data[c(var, var_parents)]
dat[[var]] <- as.integer(dat[[var]]) - 1
ans[[var]]$gam_model <- gam(forms, family = if (num_levels == 2) "binomial" else multinom(K = num_levels - 1), data = dat)
} else {
ans[[var]]$node_type <- "continuous"
form <- as.formula(paste0(var, " ~ ", paste0(sapply(var_parents, function(var_parent) {
if (class(data[[var_parent]]) == "factor") {
return(var_parent)
} else {
return(paste0("s(", var_parent, ")"))
}
}), collapse = " + ")))
dat <- data[c(var, var_parents)]
ans[[var]]$gam_model <- gam(formula = form, family = "gaussian", data = dat)
ans[[var]]$gam_model$sd <- sd(dat[[var]])
}
}
ans <- list(dag = dag, gam_fits = ans)
class(ans) <- "non_parametric_dag_model"
return(ans)
}
#' @title Simulate a dataset from a non parametric DAG model
#'
#' @description Simulate a dataset from a non parametric dag model.
#'
#' @param dag_model An object of class "non_parametric_dag_model".
#' @param N Number of observations to simulate.
#' @param ... Additional arguments
#' @return A dataset simulated from the input dag model
#' @example examples/example_sim_mixed_dag.parametric_dag_model.R
#' @seealso \code{link{sim_mixed_dag.parametric_dag_model}} for parametric dag simulation.
#' @import gam
#' @importFrom mgcv multinom
#' @export
sim_mixed_dag.non_parametric_dag_model <- function(dag_model, N = 1000, treatment_list = list()) {
dag <- dag_model$dag
gam_fits <- dag_model$gam_fits
if (mean(names(gam_fits) %in% names(dag)) != 1 | length(names(dag)) != length(names(gam_fits))) stop("some variable entries in gam_fits don't match node names in supplied DAG")
env <- environment()
list2env(treatment_list[[1]], envir = env)
vars <- names(dag)
f_discrete <- function(gam_model, target_levels, parents, N, env) {
if(length(parents) == 0){
newdata <- data.frame(const = rep(1,N))
} else {
newdata <- list()
for (parent in parents) {
newdata[[parent]] <- try(eval(parse(text = parent), envir = env), silent = T)
if (class(newdata[[parent]]) == "try-error") {
if (gam_fits[[parent]]$node_type == "discrete") {
assign(parent, do.call(f_discrete, list(
gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
target_levels = gam_fits[[parent]]$target_levels,
N = N,
env = env
), envir = env), pos = env)
} else if (gam_fits[[parent]]$node_type == "continuous") {
assign(parent, do.call(f_continuous, list(
gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
target_levels = gam_fits[[parent]]$target_levels,
N = N,
env = env
), envir = env), pos = env)
}
newdata[[parent]] <- eval(parse(text = parent), envir = env)
}
}
newdata <- as.data.frame(lapply(newdata, function(x) replace(x, is.na(x), sample(x = x[!is.na(x)], sum(is.na(x)), replace = T)))) # TODO: figure out why this is needed
}
pred <- predict(gam_model, newdata, type = "response")
if (length(target_levels) == 2) {
return(target_levels[sapply(pred, function(p) rbinom(1, 1, p)) + 1])
} else {
return(factor(target_levels[apply(pred, 1, function(p_vec) which(rmultinom(1, 1, p_vec) == 1))], levels = target_levels))
}
}
f_continuous <- function(gam_model, parents, N, env) {
if(length(parents) == 0) {
newdata <- data.frame(const = rep(1, N))
} else {
newdata <- list()
for (parent in parents) {
newdata[[parent]] <- try(eval(parse(text = parent), envir = env), silent = T)
if (class(newdata[[parent]]) == "try-error") {
if (gam_fits[[parent]]$node_type == "discrete") {
assign(parent, do.call(f_discrete, list(
gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
target_levels = gam_fits[[parent]]$target_levels,
N = N,
env = env
), envir = env), pos = env)
} else if (gam_fits[[parent]]$node_type == "continuous") {
assign(parent, do.call(f_continuous, list(
gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
N = N,
env = env
), envir = env), pos = env)
}
newdata[[parent]] <- eval(parse(text = parent), envir = env)
}
}
newdata <- as.data.frame(newdata)
}
return(as.vector(predict(gam_model, newdata, type = "response")) + rnorm(n = nrow(newdata), sd = gam_model$sd))
}
for (var in vars) {
if (!exists(var, envir = env)) {
if (gam_fits[[var]]$node_type == "discrete") {
assign(var, do.call(f_discrete, list(
gam_model = gam_fits[[var]]$gam_model,
parents = gam_fits[[var]]$parents,
target_levels = gam_fits[[var]]$target_levels,
N = N,
env = env
)), pos = env)
} else if (gam_fits[[var]]$node_type == "continuous") {
assign(var, do.call(f_continuous, list(
gam_model = gam_fits[[var]]$gam_model,
parents = gam_fits[[var]]$parents,
N = N,
env = env
)), pos = env)
}
}
}
return(setNames(data.frame(lapply(vars, function(var) eval(parse(text = var)))), vars))
}
#' @title sim_mixed_dag
#'
#' @description \code{sim_mixed_dag} is a generic function used to simulate
#'   datasets from paramteric and non paramteric DAG models.
#'
#' @param dag_model An object of either class 'paramteric_dag_model' or
#'   'non_paramteric_dag_model'.
#' @param ... additional arguments to dispatched method.
#' @return A data.frame simulated from \code{dag_model}.
#' @seealso \code{\link{sim_mixed_dag.non_parametric_dag_model}}, \code{\link{sim_mixed_dag.parametric_dag_model}}
#' @export
sim_mixed_dag <- function(dag_model, ...) UseMethod("sim_mixed_dag")
require(carData); require(dagitty)
data("GSSvocab")
GSSvocab <- GSSvocab[complete.cases(GSSvocab), ]
g <- dagitty("dag {
ageGroup [pos=\"0,0\"]
vocab [pos=\"1,-1\"]
nativeBorn [pos=\"2,-2\"]
educ [pos=\"3,-1\"]
gender [pos=\"4,0\"]
nativeBorn -> educ
nativeBorn -> vocab
educ -> vocab
gender -> educ
ageGroup -> vocab
}")
plot(g)
non_param_dag_model <- non_parametric_dag_model(dag = g, data = GSSvocab)
nativeBorn_ate_on_vocab <- get_ate(non_param_dag_model, treatment = "nativeBorn", exposure = "vocab")
print()
library(gam)
library(mgcv)
non_param_dag_model <- non_parametric_dag_model(dag = g, data = GSSvocab)
nativeBorn_ate_on_vocab <- get_ate(non_param_dag_model, treatment = "nativeBorn", exposure = "vocab")
#' @title Get \eqn{ATE} for a non paramteric DAG model
#'
#' @description \code{get_ate.non_parametric_dag_model} uses simulations
#'   to calculate the average treatment effect (\eqn{ATE}) of
#'   a treatment variable on an exposure variable given
#'   a non parametric DAG model.
#'
#' @param dag_model An object of class "non_parametric_dag_model".
#' @param treatment Name of the treatment variable.
#' @param treatment_vals A vector of treatment values to be considered.
#' @param exposure Name of the exposure variable.
#' @param M Number of simulations to run. Each simulation dataset consists of 1000 observations.
#' @return A data.frame with 3 columns:
#'   1. From: The baseline treatment value.
#'   1. To: The value a treatment was changed to.
#'   1. ATE: The average treatment effect of changing the treatment
#'   value from "From" to "To.
#' @example examples/example_get_ate.non_parametric_dag_model.R
#' @seealso \code{\link{get_ate.parametric_dag_model}} for parametric DAG model \eqn{ATE} calculation.
#' @importFrom dagitty parents
#' @export
get_ate.non_parametric_dag_model <- function(dag_model, treatment = NULL, treatment_vals = NULL, exposure = NULL, M = 1000) {
N <- 1000
dag <- dag_model$dag
gam_fits <- dag_model$gam_fits
if (gam_fits[[exposure]]$node_type != "continuous") stop("Exposure must be continuous")
if (is.null(treatment_vals)) {
if(gam_fits[[treatment]]$node_type == "continuous"){
sample_treatment <- sim_mixed_dag(dag_model)[[treatment]]
treatment_vals <- unname(quantile(sample_treatment, seq(0.05, 0.95, by = 0.3)))
} else if (gam_fits[[treatment]]$node_type == "discrete"){
treatment_vals <- factor(non_param_dag_model$gam_fits[[treatment]]$target_levels)
}
}
results <- matrix(ncol = length(treatment_vals), nrow = M)
ans <- data.frame(from = head(treatment_vals, -1), to = tail(treatment_vals, -1), ATE = NA)
vars <- names(dag)
vars <- vars[vars != treatment]
parents <- setNames(lapply(vars, function(var) dagitty::parents(dag, var)), vars) # TODO don't simulate detached nodes after removing treatment
env <- environment()
for (i in 1:length(treatment_vals)) {
treatment_ls <- setNames(list(rep(treatment_vals[i], N)), nm = treatment)
for (m in 1:M) {
sim_data <- do.call(sim_mixed_dag, list(dag_model = dag_model, N = N, treatment_ls))
results[m, i] <- mean(sim_data[[exposure]])
}
}
ans$ATE <- diff(apply(results, 2, mean))
return(ans)
}
nativeBorn_ate_on_vocab <- get_ate(non_param_dag_model, treatment = "nativeBorn", exposure = "vocab")
